# üåê Nginx Web Server
### Beginner-Friendly Guide for DevOps Engineers and Cloud Engineers

#### ‚û°Ô∏è What is Nginx?
Nginx is high performance web server used to serve the websites and web applications 

## üß∞ Common DevOps Use cases
| Use case | Example |
| :-------- | :------- |
| Web Server     | Serves static and dynamic web content    |
| Reverse Proxy       | Routes client requests to backend servers    |   
| Load Balancer      | Distributes traffic across multiple servers   | 
| API Gateway      | Handles API routing, caching, and rate limiting   |  
| Ingress      | Managing traffic inside Kubernetes clusters   |

## üõ†Ô∏è Installation of the Nginx

üêß On Ubuntu/Debian

```bash
sudo apt update
sudo apt install nginx -y
```

üì¶ On RHEL/CentOS
```bash
sudo apt update
sudo apt install nginx -y
```
üê≥ On Docker Container

‚ùó Install the Docker Engine to run the Nginx On Docker 
```bash
docker pull nginx
docker run --name nginx -p 8080:80 -d nginx
```
Visit http://localhost:8080 it will open the default Nginx file in the web browser

## üìÇ Configuration File Structure for Nginx in Linux

| File / Directory              | Purpose                                                |
| ----------------------------- | ------------------------------------------------------ |
| `/etc/nginx/nginx.conf`       | Main Nginx configuration file                          |
| `/etc/nginx/sites-available/` | Stores all virtual host (server block) configurations  |
| `/etc/nginx/sites-enabled/`   | Contains symbolic links to enabled site configurations |
| `/etc/nginx/conf.d/`          | Stores additional modular configuration files          |
| `/var/www/html`               | Default web root directory                             |
| `/var/log/nginx/access.log`   | Records all incoming HTTP requests                     |
| `/var/log/nginx/error.log`    | Stores error and diagnostic logs                       |
| `/run/nginx.pid`              | Stores the Nginx master process ID                     |

# üåê Chapter 1: Nginx Web Server

## üö© Goal 
Learn how to use the Nginx to serve static content such as HTML, CSS, JavaScript and Images

## ‚û°Ô∏è What Is a Web Server?

A web server is software (and sometimes the hardware it runs on) that receives requests from clients (usually web browsers) and delivers web content such as HTML pages, images, CSS, JavaScript, or API responses over the internet using HTTP/HTTPS.

#### Types of Content Served
- Static content: HTML, CSS, images, videos
- Dynamic content: Generated by backend applications (PHP, Node.js, Python, etc.)

## üìÅ Default Web configuration path
| File / Directory              | Purpose                                                |
| ----------------------------- | ------------------------------------------------------ |
| `/etc/nginx/sites-available/default`       | Default config file server as web browser                          |
| `/var/www/html`               | Default web root directory                             |

## ‚öíÔ∏è Sample Nginx Web Server Configuration
```nginx
server {
    listen 80;
    server_name localhost;

    root /var/www/html;
    index index.html index.htm;

    location / {
        try_files $uri $uri/ =404;
    }

    error_log /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
}
```
## Demo: Serve static Website 
1. Create a HTML file:

```bash
touch index.html
echo "<h1>Hello Learners from the created Nginx file</h1>" >> index.html
mv index.html /var/www/html/
```
2. Reload the Nginx

```bash
systemctl reload nginx
```
3. Test visit the http://localhotst:8080 or IP of the server with port 8080

## Configuration Explanation

| Directive | Description |
|---------|-------------|
| `listen 80` | Listens for HTTP requests |
| `server_name` | Domain or hostname |
| `root` | Website root directory |
| `index` | Default index file |
| `location /` | Request handling block |
| `try_files` | Checks if file exists |

## üîî Common HTTP Error Code
| Status Code | Name                       | Explanation                                                          |
| ----------- | -------------------------- | -------------------------------------------------------------------- |
| **200**     | OK                         | Request was successful and the server returned the expected response |
| **301**     | Moved Permanently          | Resource has been permanently moved to a new URL                     |
| **302**     | Found (Temporary Redirect) | Resource is temporarily available at a different URL                 |
| **400**     | Bad Request                | Server cannot process the request due to invalid syntax              |
| **401**     | Unauthorized               | Authentication is required to access the resource                    |
| **403**     | Forbidden                  | Server understood the request but denies access                      |
| **404**     | Not Found                  | Requested resource does not exist on the server                      |
| **405**     | Method Not Allowed         | HTTP method is not allowed for this resource                         |
| **408**     | Request Timeout            | Client took too long to send a request                               |
| **413**     | Payload Too Large          | Request body is larger than the server allows                        |
| **429**     | Too Many Requests          | Client sent too many requests in a given time                        |
| **500**     | Internal Server Error      | Generic server error                                                 |
| **502**     | Bad Gateway                | Server received an invalid response from an upstream server          |
| **503**     | Service Unavailable        | Server is currently unavailable or overloaded                        |
| **504**     | Gateway Timeout            | Upstream server did not respond in time                              |

## ü§ì Key Learnings

1. Role of a Web Server: Nginx serves web content to users, handles HTTP/HTTPS requests, and can act as a reverse proxy or load balancer.
2. Core Nginx Configuration: The main configuration file (nginx.conf) controls server behavior, virtual hosts, logging, and request handling.
3. HTTP Status Codes Matter: Understanding common HTTP error codes (e.g., 404, 500, 502) helps troubleshoot server and application issues efficiently.

# üåê Chapter 2: Nginx as Reverse Proxy

## ‚û°Ô∏è What is Reverse Proxy?
A reverse proxy in NGINX is when NGINX sits in front of one or more backend servers and forwards client requests to them, then sends the responses back to the clients.

## How it works (step by step)

1. A user requests https://example.com
2. The request reaches NGINX
3. NGINX forwards the request to a backend server (for example, a Node.js, Python, or Java app)
4. The backend processes the request and sends a response to NGINX
5. NGINX returns the response to the user

## üìå Why use NGINX as a reverse proxy?

### Common reasons include:

- Security ‚Äì backend servers are not exposed directly to the internet
- Load balancing ‚Äì distribute traffic across multiple backend servers
- SSL/TLS termination ‚Äì handle HTTPS in NGINX instead of the app
- Caching ‚Äì speed up responses
- Compression ‚Äì reduce response size
- Centralized routing ‚Äì route different URLs to different services

## üìù Reverse Proxy Configuration on Linux
### üîß File Path: `/etc/nginx/sites-available/default`

The configuration file as shown in the below:
```nginx
server {
    listen 80;
    server_name localhost;

    location / {
        proxy_pass http://localhost:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
````
### Breakdown:
- proxy_pass ‚Üí forwards requests to your backend app
- proxy_set_header ‚Üí preserves original request metadata (like IP and host)

## üéØ Goal of Demo

We will access the python app from nginx with port 80 
```scss
Browser ‚Üí NGINX (port 80) ‚Üí Backend app (port 5000)
```
The user will access NGINX, not the backend directly.
### Step 1: Create a simple backend app (Python)
Install Flask 
```bash
pip install flask
```
Create the `app.py` file and write the below code
```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello from Backend Server (Python Flask)"

@app.route("/api")
def api():
    return "This response came through NGINX Reverse Proxy"

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5000)
```
Run it:
```bash
python app.py
```
Test directly: 
```bash
http://localhost:5000
```
You should see:
```pgsql
Hello from Backend Server (Python Flask)
```
### Step 2: Edit the Nginx configuration file as shown below
```nginx
server {
    listen 80;
    server_name localhost;

    location / {
        proxy_pass http://localhost:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```
### Step 3: Test and Reload the Nginx
Check config: 
```bash
nginx -t
```
Once status shows üÜó, Reload the Nginx
```bash
systemctl reload nginx
```
### Step 4: Test the reverse proxy
Now open in browser:
```html
http://localhost
```
You should see:
```pgsql
Hello from Backend Server (Python Flask)
```
## ü§ì Key Learning 
1. Forwards client requests to backend servers.
2. Hides and protects backend applications.
3. Improves performance with load balancing and SSL handling.

# üåê Chapter 3: Load Balancer

## ‚û°Ô∏è What is the Load Balancer?
A load balancer is a component that distributes incoming client requests across multiple backend servers so that no single server gets overloaded.

In Nginx, a load balancer sits in front of multiple servers (like Flask apps) and decides which server should handle each request.

üö¶ Think of it like a traffic police officer directing cars to different roads.

## ‚û°Ô∏è Why Do We Use a Load Balancer?
1. High Availability
   - If one server crashes, others still handle requests.
2. Better Performance
   - Traffic is shared, so response time is faster.
3. Scalability
   - You can add more servers without changing client code.
4. Fault Tolerance
    - Nginx can stop sending traffic to a failed server.
5. Efficient Resource Usage
    - Prevents one server from being overloaded.

## How Does Nginx Load Balancing Work?
1. Client sends request ‚Üí http://localhost
2. Nginx receives the request
3. Nginx forwards it to one of the backend servers
4. Backend server responds
5. Nginx sends response back to client

## Common Load Balancing Algorithms
| **Algorithm**                  | **One-Line Explanation**                                             |
| ------------------------------ | -------------------------------------------------------------------- |
| **Round Robin**                | Distributes requests sequentially to each server one by one.         |
| **Least Connections**          | Sends requests to the server with the fewest active connections.     |
| **IP Hash**                    | Routes requests from the same client IP to the same server.          |
| **Weighted Round Robin**       | Sends more requests to servers with higher assigned weight.          |
| **Weighted Least Connections** | Chooses the server with least connections considering server weight. |
| **Random**                     | Randomly selects a backend server for each request.                  |
| **Hash (URL/Key Hash)**        | Uses a hash of a request attribute (URL/key) to select a server.     |
| **Failover**                   | Routes traffic only to backup servers when primary servers fail.     |

## üß™ Demo: Load Balancing with Two Flask Applications
### üï∏Ô∏è Workflow of Load Balancer
```css
Client
   ‚Üì
 Nginx (Port 80)
   ‚Üì
-----------------
| Flask App 1  |  (Port 5001)
| Flask App 2  |  (Port 5002)
-----------------
```

### Step 1: Create two simple backend app (Python)
Install Flask 
```bash
pip install flask
```
### üëâ Create the `app1.py` file and write the below code 

```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello from Flask App 1 (Port 5001)"

if __name__ == "__main__":
    app.run(port=5001)
```
Run it: 
```bash
python app1.py
```
### üëâ Create the `app2.py` file and write the below code 
```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "Hello from Flask App 2 (Port 5002)"

if __name__ == "__main__":
    app.run(port=5002)
```
Run it:
```bash
python app2.py
```
### Step 2: Nginx configuration as Load Balancer

Edit Nginx configuration(`Nginx.conf` or `/etc/nginx/conf.d/default.conf`):
```nginx
http {
    upstream flask_backend {
        server 127.0.0.1:5001;
        server 127.0.0.1:5002;
    }

    server {
        listen 80;

        location / {
            proxy_pass http://flask_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

- upstream ‚Üí defines backend servers
- proxy_pass ‚Üí forwards requests
- Default algorithm ‚Üí Round Robin

**Check config:** 
```bash
nginx -t
```
Once status shows üÜó

**Reload the Nginx**
```bash
systemctl reload nginx
```
### Step 3: Test the reverse proxy
Now open in browser:
```html
http://localhost
```
Refresh multiple times üîΩ

You will see the response alternate:
```css
Hello from Flask App 1 (Port 5001)
Hello from Flask App 2 (Port 5002)
```
### ü§ì Key Learnings
- Nginx Load Balancer distributes traffic across servers
- Improves performance, reliability, scalability
- Easy to configure
- Works perfectly with Flask apps

# üåê Chapter 4: API Gateway
## ‚û°Ô∏è What is API  Gateway in Nginx?

An API gateway is a single entrypoint that sits between clients and backend services and it's 

Instead of the client talking directly to many services:
```arduino
Client ‚Üí Service A
Client ‚Üí Service B
Client ‚Üí Service C
```
The client talks to one gateway:
```arduino
Client ‚Üí API Gateway ‚Üí Service A
                     ‚Üí Service B
                     ‚Üí Service C
```

## ü§î Why Do We Need an API Gateway?
**Problems Without an API Gateway**

If clients directly access services:

- Client must know multiple URLs
- Security logic is duplicated
- No centralized logging
- Hard to scale services independently
- Load balancing is complex

## ü§ì How API Gateway resolve above issue ‚ùì

| Feature         | Why it matters                      |
| --------------- | ----------------------------------- |
| Routing         | Forward requests to correct service |
| Load balancing  | Distribute traffic                  |
| Security        | Auth, rate limiting                 |
| SSL termination | HTTPS handled in one place          |
| Logging         | Central request logs                |
| Abstraction     | Backend services can change         |

## üòé How Nginx Works as an API Gateway

High level Flow

```scss
Client Request
     ‚Üì
Nginx (API Gateway)
     ‚Üì
Route Decision
     ‚Üì
Backend Service (Flask App)
     ‚Üì
Response
```
**Breakdown:**
* **Client Request**: The client (browser, mobile app, or API consumer) sends an HTTP request to a single public endpoint.
* **Nginx (API Gateway)**: Nginx receives the request and acts as a reverse proxy, security layer, and traffic controller.
* **Route Decision**: Nginx checks the request path, method, or headers and decides which backend service should handle it.
* **Backend Service (Flask App)**: The selected Flask application processes the request and generates a response.
* **Response**: The response flows back through Nginx to the client, appearing as if it came from one unified API.

## üß™ Demo: API Gateway with Flask applications 

### Architecture of Our Demo
```bash
Client
  |
  | http://localhost:8080/api/user
  | http://localhost:8080/api/product
  |
Nginx API Gateway (Port 8080)
  |
  |----> Flask App 1 (User Service)     Port 5001
  |----> Flask App 2 (Product Service)  Port 5002
```

### Step 1: Flask Application 1 ‚Äì User Service
Create a file üìÅ `user_service.py` and insert the below code:
```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/user')
def user():
    return jsonify({
        "service": "User Service",
        "message": "Hello from User API"
    })

if __name__ == '__main__':
    app.run(port=5001)
```
### Step 2: Flask Application 2 ‚Äì Product Service
Create a file üìÅ `product_service.py` and insert the below code:
```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/product')
def product():
    return jsonify({
        "service": "Product Service",
        "message": "Hello from Product API"
    })

if __name__ == '__main__':
    app.run(port=5002)
```
### Step 3: Nginx Configuration as API Gateway
Edit Nginx configuration(`Nginx.conf` or `/etc/nginx/conf.d/default.conf`):
```nginx
events {}

http {

    upstream user_service {
        server 127.0.0.1:5001;
    }

    upstream product_service {
        server 127.0.0.1:5002;
    }

    server {
        listen 8080;

        location /api/user/ {
            proxy_pass http://user_service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location /api/product/ {
            proxy_pass http://product_service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```
**How Routing Works Here**
| Client Request         | Routed To             |
| ---------------------- | --------------------- |
| `/api/user/user`       | Flask User Service    |
| `/api/product/product` | Flask Product Service |

### Step 4: Running the Demo
Start Flask Apps
```bash
python user_service.py
python product_service.py
```
**Check config:** 
```bash
nginx -t
```
Once status shows üÜó

**Reload the Nginx**
```bash
systemctl reload nginx
```

### Step 5: Test Requests

```bash
curl http://localhost:8080/api/user/user
```

**Output:**
```json
{
  "service": "User Service",
  "message": "Hello from User API"
}
```

```bash
curl http://localhost:8080/api/product/product
```

**Output:**
```json
{
  "service": "Product Service",
  "message": "Hello from Product API"
}
```
## ü§ì Key Learnings

**Nginx as an API Gateway:**
- Accepts all client requests
- Routes to correct backend service
- Improves security, scalability, and maintainability
- Ideal for microservices architectures

## üòçContributions are welcome!  
If you are interested in contributing to this learning project, please feel free to:

- Fork the repository  
- Create a new branch  
- Make your changes  
- Submit a Pull Request  

For any questions or suggestions, feel free to open an issue.

